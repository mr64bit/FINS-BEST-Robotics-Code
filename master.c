#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl2,  touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl3,  touchArm,       sensorTouch)
#pragma config(Sensor, dgtl4,  redLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl5,  greenLED,       sensorDigitalOut)
#pragma config(Motor,  port2,           arm1,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           grip1,         tmotorServoStandard, openLoop, reversed)
#pragma config(Motor,  port4,           grip2,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           drive1,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           drive2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           rope1,         tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float mDrive = 0;
float mArm = 0;
float sGripL = 0;
float sGripR = 0;
int joy2 = 0;
float joy2a = 0; //second var needed because floating point math won't work in lines with vexRT
int joy3 = 0;
int potIn = 0;
float armPos = 0;
const float pK = 7;
float error = 0;
float potMult = -.32;
int mRope = 0;
int hold = 0;

task leds()
{
	while(true)
		{
			SensorValue(redLED) = 1; //flash the LEDs on and off
			SensorValue(greenLED) = 0;
			wait1Msec(500);
			SensorValue(redLED) = 0;
			SensorValue(greenLED) = 1;
			wait1Msec(500);
		}
}

task main()
{
	StartTask(leds);
	potIn = (SensorValue(pot) / potMult) + 127; //this is to read the position of the arm before we move it
	armPos = potIn;
	while(true)
		{
			potIn = (SensorValue(pot) / potMult) + 127; //average the potentiometer's input so it has the same range as the motor
			if(abs(vexRT[Ch2]) < 10) //start of joystick value cutting
				{
					joy2 = 0;
				}
			else
				{
					joy2 = vexRT[Ch2];
				}
			if(abs(vexRT[Ch3]) < 10)
				{
					joy3 = 0;
				}
			else
				{
					joy3 = vexRT[Ch3]; //end joystick value cutting
				}
			if((SensorValue(touchBottom) == 1) && (joy3 <= 0)) //for future implementation of touch sensors
				{
					joy3 = 0;
				}
			if((SensorValue(touchTop) == 1) && (joy3 >= 0))
				{
					joy3 = 0;
				}
			if((SensorValue(touchArm) == 1) && (joy2 <= 0))
				{
					joy2 = 0;
				}
			if(vexRT[Btn7L] == 1) { hold = 30; } //gear motor lock toggle
			if(vexRT[Btn7D] == 1) { hold = 0; }
			mDrive = ((mDrive * 19) + joy3) / 20; //exponential averaging
			joy2a = ((joy2a * 9) + joy2) / 10;
			if(vexRT[Btn6D] == 1) //button controls for the grippers
				{
					sGripL = -60;
				}
			if(vexRT[Btn6U] == 1)
				{
					sGripL = 120;
				}
			if(vexRT[Btn5D] == 1)
				{
					sGripR = -60;
				}
			if(vexRT[Btn5U] == 1)
				{
					sGripR = 120;
				}
			if(vexRT[Btn8U] == 1) //button controls for the winch motor
				{
					mRope = 127;
				}
			if(vexRT[Btn8D] == 1)
				{
					mRope = -128;
				}
			if(vexRT[Btn8U] == 0 && vexRT[Btn8D] == 0)
				{
					mRope = 0;
				}
			//proportional loop
				armPos += (joy2a / 300); //number changes speed of arm movement
				if(armPos > 135) { armPos = 135; }
				if(armPos < 0) { armPos = 0; }
				error = armPos - potIn;
				mArm = error * pK;
				if(joy2a > 20)
					{
						if(error > 30) {armPos = potIn + 30; } //keep the projected position within 30 of the actual position while moving up
					}
				//if(error < -30) {armPos = potIn - 30; }
			//end loop
			motor[drive1] = mDrive + hold; //powering all the motors according to their variables
			motor[drive2] = mDrive + hold;
			motor[arm1] = mArm;
			motor[grip1] = sGripL;
			motor[grip2] = sGripR;
			motor[rope1] = mRope;
			wait1Msec(10);
		}
}
