#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  touchTop,       sensorTouch)
#pragma config(Sensor, dgtl2,  touchBottom,    sensorTouch)
#pragma config(Sensor, dgtl3,  touchArm,       sensorTouch)
#pragma config(Sensor, dgtl4,  redLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl5,  greenLED,       sensorDigitalOut)
#pragma config(Motor,  port2,           arm1,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           grip1,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           grip2,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           drive1,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           drive2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           rope1,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           track,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           bottle,        tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float mDrive = 0;
float mArm = 0;
float sGripL = 0;
float sGripR = 0;
int joy2 = 0;
float joy2a = 0; //second var needed because floating point math won't work in lines with vexRT
int joy3 = 0;
int potIn = 0;
float armPos = 0;
const float pK = 7;
float error = 0;
float potMult = -.32;
int mRope = 0;
int hold = 30;
float sTrack = 0;
int sBottle = 0;
int mapa[4];
int mapb[4];

task leds()
{
	while(true)
		{
			SensorValue(redLED) = 1; //flash the LEDs on and off
			SensorValue(greenLED) = 0;
			wait1Msec(500);
			SensorValue(redLED) = 0;
			SensorValue(greenLED) = 1;
			wait1Msec(500);
		}
}

task main()
{
	StartTask(leds);
	potIn = (SensorValue(pot) / potMult) + 127; //this is to read the position of the arm before we move it
	armPos = potIn;
	while(true)
		{
			potIn = (SensorValue(pot) / potMult) + 127; //average the potentiometer's input so it has the same range as the motor
			if(abs(vexRT[Ch2]) < 10) //start of joystick value cutting
				{
					joy2 = 0;
				}
			else
				{
					joy2 = vexRT[Ch2];
				}
			if(abs(vexRT[Ch3]) < 10)
				{
					joy3 = 0;
				}
			else
				{
					joy3 = vexRT[Ch3]; //end joystick value cutting
				}
			if((SensorValue(touchBottom) == 1) && (joy3 <= 0)) //for future implementation of touch sensors
				{
					joy3 = 0;
				}
			if((SensorValue(touchTop) == 1) && (joy3 >= 0))
				{
					joy3 = 0;
				}
			if((SensorValue(touchArm) == 1) && (joy2 <= 0))
				{
					joy2 = 0;
				}
			if(vexRT[Btn7U] == 1) { hold = 30; } //gear motor lock toggle
			if(vexRT[Btn7R] == 1) { hold = 0; }
			mDrive = ((mDrive * 19) + joy3) / 20; //exponential averaging
			joy2a = ((joy2a * 9) + joy2) / 10;
			if(vexRT[Btn6U] == 1) //button controls for the grippers
				{
					sGripL = -60;
				}
			if(vexRT[Btn6D] == 1)
				{
					sGripL = 120;
				}
			if(vexRT[Btn5D] == 1)
				{
					sGripR = -60;
				}
			if(vexRT[Btn5U] == 1)
				{
					sGripR = 120;
				}
			if(vexRT[Btn8U] == 1) //button controls for the winch motor
				{
					mRope = 127;
				}
			if(vexRT[Btn8D] == 1)
				{
					mRope = -128;
				}
			if(vexRT[Btn8U] == 0 && vexRT[Btn8D] == 0)
				{
					mRope = 0;
				}

			if(vexRT[Btn8R] == 1)
			{
				mapb[0] = 0;
				mapb[1] = 1;
				mapb[2] = 2;
				mapb[3] = 3;
			}
			if(vexRT[Btn8L] == 1)
			{
				mapb[0] = 3;
				mapb[1] = 2;
				mapb[2] = 1;
				mapb[3] = 0;
			}
			mapa[0] = vexRT[Btn7L];
			mapa[1] = vexRT[Btn7D];
			mapa[2] = vexRT[Btn8U];
			mapa[3] = vexRT[Btn8D];
			sTrack = sTrack + (mapa[mapb[0]] * .75);
			sTrack = sTrack + (mapa[mapb[1]] * -.75);
			if(sTrack > 127) { sTrack = 127; }
			if(sTrack < -128) { sTrack = -128; }
			if(mapa[mapb[2]] == 1) { sBottle = 100; }
			if(mapa[mapb[3]] == 1) { sBottle = -100; }

			//proportional loop
				armPos += (joy2a / 300); //number changes speed of arm movement
				if(armPos > 135) { armPos = 135; }
				if(armPos < 0) { armPos = 0; }
				error = armPos - potIn;
				mArm = error * pK;
				if(joy2a > 20)
					{
						if(error > 30) {armPos = potIn + 30; } //keep the projected position within 30 of the actual position while moving up
					}
				//if(error < -30) {armPos = potIn - 30; }
			//end loop
			motor[drive1] = -mDrive - hold; //powering all the motors according to their variables
			motor[drive2] = mDrive + hold;
			motor[arm1] = mArm;
			motor[grip1] = sGripL;
			motor[grip2] = sGripR;
			motor[rope1] = mRope;
			motor[track] = sTrack;
			motor[bottle] = sBottle;
			wait1Msec(10);
		}
}
